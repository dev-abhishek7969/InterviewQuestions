<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Important Questions & Answers</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background-color: #f9f9f9;
    }

    h1 {
      text-align: center;
      color: #333;
    }

    /* Tabs container */
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
      gap: 15px;
    }

    /* Individual tab */
    .tab {
      padding: 12px 30px;
      background-color: #eee;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      color: #444;
      transition: background-color 0.3s ease;
      user-select: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    .tab:hover {
      background-color: #ddd;
    }

    .tab.active {
      background-color: #007BFF;
      color: white;
      box-shadow: 0 4px 12px rgba(0,123,255,0.4);
    }

    /* Accordion styles (your original) */
    .accordion {
      background-color: #eee;
      color: #444;
      cursor: pointer;
      padding: 15px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 16px;
      transition: background-color 0.3s;
      margin-top: 10px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .accordion:hover {
      background-color: #ccc;
    }

    .active, .accordion:active {
      background-color: #ccc;
    }

    .panel {
      padding: 0 15px;
      background-color: white;
      display: none;
      overflow: hidden;
      border-left: 2px solid #007BFF;
      border-right: 2px solid #007BFF;
      border-bottom: 2px solid #007BFF;
      border-radius: 0 0 5px 5px;
    }

    .panel p {
      margin: 10px 0;
      white-space: pre-wrap; /* keep your pre formatting */
      font-family: monospace;
    }

    /* Container for each tab content */
    .tab-content {
      max-width: 900px;
      margin: 0 auto;
    }

    /* Hide all tab content by default */
    .tab-content > div {
      display: none;
    }

    /* Show active tab content */
    .tab-content > div.active {
      display: block;
    }
  </style>
</head>
<body>

  <h1>Important Questions & Answers</h1>

  <div class="tabs" role="tablist" aria-label="Question Categories">
    <div class="tab active" role="tab" tabindex="0" aria-selected="true" aria-controls="spring-questions" id="tab-spring">Spring</div>
    <div class="tab" role="tab" tabindex="-1" aria-selected="false" aria-controls="basics-questions" id="tab-basics">Core Java</div>
  </div>

  <div class="tab-content">
    <!-- Spring Questions -->
    <div id="spring-questions" class="active" role="tabpanel" aria-labelledby="tab-spring">
      <button class="accordion">1. The Role of @Qualifier in Dependency Injection?</button>
      <div class="panel">
        <p>
The @Qualifier annotation is used in scenarios where an interface has multiple implementation classes. 
When you are autowiring an interface, there can be ambiguity about which specific implementation class's object should be initialized. 
In such cases, the @Qualifier annotation is added to explicitly indicate which implementation class object must be injected for that particular interface type

public interface NotificationService {
    void send(String message);
}

And you have two different implementations of this interface, one for email and one for SMS:

// Email implementation
@Service("emailNotification") // Giving it a specific qualifier name
public class EmailNotificationService implements NotificationService {
    @Override
    public void send(String message) {
        System.out.println("Sending email: " + message);
    }
}

// SMS implementation
@Service("smsNotification") // Giving it another specific qualifier name
public class SMSNotificationService implements NotificationService {
    @Override
    public void send(String message) {
        System.out.println("Sending SMS: " + message);
    }
}

Now, if you want to inject a `NotificationService` into another class, Spring would not know which implementation to choose by default. 
This is where `@Qualifier` comes in. You use it along with `@Autowired` to specify which bean to inject:

@Component
public class UserService {

    @Autowired
    @Qualifier("emailNotification") // Explicitly requesting the EmailNotificationService
    private NotificationService emailService;

    @Autowired
    @Qualifier("smsNotification") // Explicitly requesting the SMSNotificationService
    private NotificationService smsService;

    public void notifyUserByEmail(String user, String message) {
        System.out.println("Notifying " + user + " via email:");
        emailService.send(message);
    }

    public void notifyUserBySms(String user, String message) {
        System.out.println("Notifying " + user + " via SMS:");
        smsService.send(message);
    }
}
In this example, `@Qualifier("emailNotification")` ensures that the `emailService` field receives an instance of `EmailNotificationService`, 
and `@Qualifier("smsNotification")` ensures `smsService` receives an instance of `SMSNotificationService`, resolving the ambiguity that would otherwise occur.
        </p>
      </div>
	  
	  <button class="accordion">2. What is CSS?</button>
      <div class="panel">
        <p>CSS stands for Cascading Style Sheets. It is used for designing and customizing the look and feel of a webpage.</p>
      </div>
	  
    </div>

    <!-- Basics Questions -->
    <div id="basics-questions" role="tabpanel" aria-labelledby="tab-basics">
      
	  <button class="accordion">1. What is the importance of hash code and equals method?</button>
      <div class="panel">
        <p>The `hashCode` and `equals` methods are important, especially in the context of how data structures like `HashMap` operate internally.

Here's why they are important:

*   **Internal `HashMap` Operation**: Internally, `HashMap` relies on these methods to determine where to place objects and how to find them.

*   **Custom Objects**: When you're working with **custom-defined objects**, such as a list of `Employee` class instances, `HashMap` needs to know how to calculate a hash code for these objects and how to check for equality.

*   **Proper Object Placement**: The `hashCode` and `equals` methods ensure that objects are **properly placed into the `HashMap`**. Without correct implementations for custom objects, `HashMap` might not function as expected, leading to issues like duplicate entries or an inability to retrieve stored objects.</p>
      </div>

      <button class="accordion">What are the benefits of Concurrent HashMap</button>
      <div class="panel">
        <p>| Benefit                    | Explanation                                    |
| -------------------------- | ---------------------------------------------- |
| Thread-safe concurrency    | Multiple threads can read/write safely         |
| High scalability           | Fine-grained locking improves throughput       |
| Non-blocking reads         | Reads don’t block even during writes           |
| Better performance         | Efficient under heavy multi-threading          |
| Weakly consistent iterator | Safe to iterate during concurrent modification |
| No null keys/values        | Avoids ambiguity and errors                    |
</p>
      </div>
	  
	  
	  <button class="accordion">How to create immutable class in java</button>
      <div class="panel">
        <p>public final class Person {
    private final String name;
    private final int age;
    private final List<String> hobbies;  // mutable collection

    public Person(String name, int age, List<String> hobbies) {
        this.name = name;
        this.age = age;
        // Defensive copy to protect internal list from external changes
        this.hobbies = new ArrayList<>(hobbies);
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Return a copy to protect internal state
    public List<String> getHobbies() {
        return new ArrayList<>(hobbies);
    }
}
</p>
      </div>
	  
	  
	  <button class="accordion">What is the difference between finally and finalize?</button>
      <div class="panel">
        <p>| Aspect             | `finally`                                                                                              | `finalize`                                                                         |
| ------------------ | ------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------- |
| What is it?        | A block used in **exception handling**                                                                 | A **method** called by the garbage collector                                       |
| Purpose            | To execute code **after try/catch**, regardless of exception thrown or not                             | To perform cleanup before the object is garbage collected                          |
| Usage context      | Used along with `try` and `catch` blocks                                                               | Defined inside a class as `protected void finalize()` method                       |
| When executed?     | Immediately after the `try` and `catch` blocks finish (always executed except when JVM exits abruptly) | Called **sometime before object is destroyed** by GC (not guaranteed when exactly) |
| Typical use        | Closing resources like files, streams, releasing locks                                                 | Cleanup actions like freeing native resources (though discouraged)                 |
| Syntax example     | `java try { ... } catch(Exception e) { ... } finally { ... } `                                         | `java @Override protected void finalize() throws Throwable { ... } `               |
| Can be overridden? | Not applicable (it's a language construct)                                                             | Yes, classes can override `finalize()` method                                      |
| Reliability        | Very reliable for cleanup                                                                              | Unreliable, because GC timing is unpredictable; deprecated since Java 9            |
</p>
      </div>
	  
	  <button class="accordion">What is AutoClosable interface??</button>
      <div class="panel">
        <p>AutoCloseable is a functional interface.BufferedReader implements AutoCloseable.

The close() method is called automatically at the end of the try block, even if exceptions occur. </p>
      </div>
	  
	  <button class="accordion">What are the reasons for memory leak??</button>
      <div class="panel">
        <p>Unintentional Object Retention

Objects are kept referenced unintentionally, e.g., stored in static collections, caches, or long-lived objects.
Example: Adding objects to a static List and never removing them.

Listeners and Callbacks Not Removed,GUI components or frameworks holding references to listeners after they are no longer needed.

Inner Classes and Anonymous Classes
Non-static inner classes hold implicit reference to the outer class instance.

How to avoid memory leaks:
Remove references to objects when no longer needed.

Properly unregister listeners and callbacks.

Use weak references or WeakHashMap for caches if appropriate.

Avoid unnecessary static references.

Clean up ThreadLocal values.
</p>
      </div>
	  
	  <button class="accordion">What is volatile keyword?</button>
      <div class="panel">
        <p>| Aspect                                | Explanation                                                                                                                                                         |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Visibility                            | Updates are flushed to main memory immediately                                                                                                                      |
| Atomicity                             | Only guarantees atomic reads/writes for **primitive types** except `long` and `double` (Java 5+ atomic too) but **not for compound actions** like increment (`x++`) |
| Use case                              | Flags, status indicators, or variables shared between threads where atomicity is not required                                                                       |
| Not a replacement for synchronization | Does not provide mutual exclusion or protect compound operations                                                                                                    |
</p>
      </div>
	  
	  <button class="accordion">What is the use of method reference?</button>
      <div class="panel">
        <p>Simplify code by removing unnecessary lambda syntax.

Make code more readable and expressive.

Perfect for functional programming with streams and lambdas.</p>
      </div>
	  
	  <button class="accordion">What is indexing (in database)?</button>
      <div class="panel">
        <p>An index is a separate data structure (usually a B-tree or hash) that stores a sorted copy or pointers of one or more columns from a table.

It allows the database to efficiently look up records without scanning the entire table.

Example:
If you have a users table with thousands of rows and you frequently search by email, creating an index on the email column makes those lookups much faster.

CREATE INDEX idx_email ON users(email);

</p>
      </div>
	  
	  <button class="accordion">What is the difference between sleep and wait method?</button>
      <div class="panel">
        <p>The sleep() and wait() methods are both used in multithreading in Java
          wait() → ✅ Must be called from a synchronized block or method (or it throws IllegalMonitorStateException).
          Releases the lock on the object it's called on while waiting.
          Wakes up either by:notify() or notifyAll() (from another thread) Or if a timeout occurs (if specified)

          Thread.sleep(1000); 

          synchronized(obj) {
          obj.wait(); // Waits until notified, and releases the monitor
}
        </p>
      </div>
	  
	  <button class="accordion">?</button>
      <div class="panel">
        <p></p>
      </div>
	  
	  <button class="accordion">?</button>
      <div class="panel">
        <p></p>
      </div>
	  
	  <button class="accordion">?</button>
      <div class="panel">
        <p></p>
      </div>
	  
    </div>
  </div>

  <script>
    // Tab functionality
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content > div');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // deactivate all tabs
        tabs.forEach(t => {
          t.classList.remove('active');
          t.setAttribute('aria-selected', 'false');
          t.setAttribute('tabindex', '-1');
        });
        // hide all tab contents
        tabContents.forEach(tc => tc.classList.remove('active'));

        // activate current tab
        tab.classList.add('active');
        tab.setAttribute('aria-selected', 'true');
        tab.setAttribute('tabindex', '0');

        // show related tab content
        const contentId = tab.getAttribute('aria-controls');
        document.getElementById(contentId).classList.add('active');
      });

      // keyboard navigation for tabs
      tab.addEventListener('keydown', (e) => {
        let index = Array.from(tabs).indexOf(e.target);
        if (e.key === 'ArrowRight') {
          index = (index + 1) % tabs.length;
          tabs[index].focus();
        } else if (e.key === 'ArrowLeft') {
          index = (index - 1 + tabs.length) % tabs.length;
          tabs[index].focus();
        }
      });
    });

    // Accordion functionality
    const accordions = document.querySelectorAll('.accordion');
    accordions.forEach(button => {
      button.addEventListener('click', function() {
        this.classList.toggle('active');
        const panel = this.nextElementSibling;
        if (panel.style.display === "block") {
          panel.style.display = "none";
        } else {
          panel.style.display = "block";
        }
      });
    });
  </script>

</body>
</html>
